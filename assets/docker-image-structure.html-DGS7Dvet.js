import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,a as r}from"./app-ClyRY-uV.js";const o="/assets/image/cloud-native/docker-image-build.jpg",c={},i=r('<h1 id="docker-镜像结构" tabindex="-1"><a class="header-anchor" href="#docker-镜像结构"><span>docker 镜像结构</span></a></h1><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>docker 镜像的构建过程中，以一个基础镜像为起点，每执行一条构建指令，都会在基础镜像上添加一个新层，每个层都是只读的，并且在构建过程中会逐步叠加，最终使用<code>docker build</code>命令构建出一个新的镜像。</p><h2 id="底层" tabindex="-1"><a class="header-anchor" href="#底层"><span>底层</span></a></h2><p>最底层的kernel代表着宿主机的内核，docker 容器共享宿主机的内核，但是运行在隔离的用户空间中。</p><h2 id="基础层" tabindex="-1"><a class="header-anchor" href="#基础层"><span>基础层</span></a></h2><p>基础镜像层是构建过程的起点，它是一个轻量级的、不可变的、只读的文件系统，包含了创建容器实例所需的最小运行环境和应用程序。</p><h2 id="镜像层" tabindex="-1"><a class="header-anchor" href="#镜像层"><span>镜像层</span></a></h2><p>在基础镜像层之上，对应Dockerfile中的每一条构建指令，都会在基础镜像层上添加一个新的镜像层，每个镜像层都是只读的，并且在构建过程中会逐步叠加。</p><h2 id="顶层" tabindex="-1"><a class="header-anchor" href="#顶层"><span>顶层</span></a></h2><p>最上面一层是可写的容器层。当容器启动时，它在只读镜像层上添加一个可写层，所有对容器的改动都会发生在这个可写层上。</p><p>当容器被删除时，这个可写层也会被删除，而下面的只读镜像层则会被保留。</p>',12),d=[i];function n(p,l){return a(),t("div",null,d)}const g=e(c,[["render",n],["__file","docker-image-structure.html.vue"]]),m=JSON.parse(`{"path":"/dump/cloud-native/docker/docker-image-structure.html","title":"docker 镜像结构","lang":"zh-CN","frontmatter":{"date":"2024-03-02T00:00:00.000Z","order":4,"description":"docker 镜像结构 docker 镜像的构建过程中，以一个基础镜像为起点，每执行一条构建指令，都会在基础镜像上添加一个新层，每个层都是只读的，并且在构建过程中会逐步叠加，最终使用docker build命令构建出一个新的镜像。 底层 最底层的kernel代表着宿主机的内核，docker 容器共享宿主机的内核，但是运行在隔离的用户空间中。 基础层 基...","head":[["meta",{"property":"og:url","content":"https://guoxicheng.top/dump/cloud-native/docker/docker-image-structure.html"}],["meta",{"property":"og:site_name","content":"Guo's Page"}],["meta",{"property":"og:title","content":"docker 镜像结构"}],["meta",{"property":"og:description","content":"docker 镜像结构 docker 镜像的构建过程中，以一个基础镜像为起点，每执行一条构建指令，都会在基础镜像上添加一个新层，每个层都是只读的，并且在构建过程中会逐步叠加，最终使用docker build命令构建出一个新的镜像。 底层 最底层的kernel代表着宿主机的内核，docker 容器共享宿主机的内核，但是运行在隔离的用户空间中。 基础层 基..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://guoxicheng.top/assets/image/cloud-native/docker-image-build.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-21T06:52:13.000Z"}],["meta",{"property":"article:published_time","content":"2024-03-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-21T06:52:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"docker 镜像结构\\",\\"image\\":[\\"https://guoxicheng.top/assets/image/cloud-native/docker-image-build.jpg\\"],\\"datePublished\\":\\"2024-03-02T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-21T06:52:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"底层","slug":"底层","link":"#底层","children":[]},{"level":2,"title":"基础层","slug":"基础层","link":"#基础层","children":[]},{"level":2,"title":"镜像层","slug":"镜像层","link":"#镜像层","children":[]},{"level":2,"title":"顶层","slug":"顶层","link":"#顶层","children":[]}],"git":{"createdTime":1709363547000,"updatedTime":1718952733000},"readingTime":{"minutes":1.14,"words":342},"filePathRelative":"dump/cloud-native/docker/docker-image-structure.md","localizedDate":"2024年3月2日","autoDesc":true,"excerpt":"\\n<figure><img src=\\"/assets/image/cloud-native/docker-image-build.jpg\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<p>docker 镜像的构建过程中，以一个基础镜像为起点，每执行一条构建指令，都会在基础镜像上添加一个新层，每个层都是只读的，并且在构建过程中会逐步叠加，最终使用<code>docker build</code>命令构建出一个新的镜像。</p>\\n<h2>底层</h2>\\n<p>最底层的kernel代表着宿主机的内核，docker 容器共享宿主机的内核，但是运行在隔离的用户空间中。</p>"}`);export{g as comp,m as data};
